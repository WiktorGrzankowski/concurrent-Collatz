#ifndef TEAMS_HPP
#define TEAMS_HPP

#include <thread>
#include <assert.h>
#include <unistd.h>
#include <wait.h>

#include <sys/stat.h>
#include <sys/wait.h>
#include <sys/types.h>
#include <filesystem>
#include <fcntl.h>

#include "lib/rtimers/cxx11.hpp"
#include "lib/pool/cxxpool.h"

#include "contest.hpp"
#include "collatz.hpp"
#include "sharedresults.hpp"

#define BUF_SIZE 1024

//todo
class Team {
public:
    Team(uint32_t sizeArg, bool shareResults) : size(sizeArg), sharedResults() {
        assert(this->size > 0);

        if (shareResults) {
            this->sharedResults.reset(new SharedResults{});
        }
    }

    virtual ~Team() {}

    virtual std::string getInnerName() = 0;

    std::shared_ptr<SharedResults> getSharedResults() {
        return this->sharedResults;
    }

    virtual ContestResult runContest(ContestInput const &contest) = 0;

    std::string getXname() { return this->getSharedResults() ? "X" : ""; }

    virtual std::string getTeamName() {
        return this->getInnerName() + this->getXname() + "<" +
               std::to_string(this->size) + ">";
    }

    uint32_t getSize() const { return this->size; }


private:
    std::shared_ptr<SharedResults> sharedResults;
    uint32_t size;
};

class TeamSolo : public Team {
public:
    TeamSolo(uint32_t sizeArg) : Team(1, false) {} // ignore size, don't share

    virtual ContestResult runContest(ContestInput const &contestInput) {
        ContestResult result;
        result.resize(contestInput.size());
        uint64_t idx = 0;

        rtimers::cxx11::DefaultTimer soloTimer("CalcCollatzSoloTimer");

        for (InfInt const &singleInput : contestInput) {
            auto scopedStartStop = soloTimer.scopedStart();
            result[idx] = calcCollatz(singleInput);
            ++idx;
        }
        return result;
    }

    virtual std::string getInnerName() { return "TeamSolo"; }
};

class TeamThreads : public Team {
public:
    TeamThreads(uint32_t sizeArg, bool shareResults) : Team(sizeArg,
                                                            shareResults),
                                                       createdThreads(0) {}

    template<class Function, class... Args>
    std::thread createThread(Function &&f, Args &&... args) {
        ++this->createdThreads;
        return std::thread(std::forward<Function>(f),
                           std::forward<Args>(args)...);
    }

    void resetThreads() { this->createdThreads = 0; }

    uint64_t getCreatedThreads() { return this->createdThreads; }

private:
    uint64_t createdThreads;
};

class TeamNewThreads : public TeamThreads {
public:
    TeamNewThreads(uint32_t sizeArg, bool shareResults) : TeamThreads(sizeArg,
                                                                      shareResults) {}

    virtual ContestResult runContest(ContestInput const &contestInput) {
        this->resetThreads();
        ContestResult result = this->runContestImpl(contestInput);
        assert(contestInput.size() == this->getCreatedThreads());
        return result;
    }

    /*
     * TeamNewThreads powinien tworzyć nowy wątek dla każdego wywołania
     * calcCollatz, jednak nie więcej niż getSize() wątków jednocześnie.
     */
    virtual ContestResult runContestImpl(ContestInput const &contestInput) {
        ContestResult result;

        uint64_t MAX_THREAD_COUNT = this->getSize();
        uint64_t CONTEST_SIZE = contestInput.size();

        std::deque<std::thread> threads;
        std::promise<uint64_t> promises[CONTEST_SIZE];
        std::future<uint64_t> futures[CONTEST_SIZE];

        for (uint64_t i = 0; i < CONTEST_SIZE; ++i) {
            std::promise<uint64_t> prom;
            promises[i] = std::move(prom);
            futures[i] = promises[i].get_future();
        }

        uint64_t oldest_id = 0, current_id = 0;
        while (current_id < CONTEST_SIZE) {
            auto contest = contestInput[current_id];
            if (threads.size() == MAX_THREAD_COUNT) { // no free thread spots
                result.push_back(futures[oldest_id].get());
                // make sure the oldest thread finishes its job
                threads.front().join();
                threads.pop_front();
                ++oldest_id;
            }
            std::thread t = createThread(
                    [&, t_contest = contest,
                            &t_promise = promises[current_id]] {
                        if (this->getSharedResults())
                            t_promise.set_value(this->getSharedResults()
                                                        ->sharedCalcCollatz(
                                                                t_contest));
                        else
                            t_promise.set_value(calcCollatz(t_contest));
                    });
            threads.push_back(std::move(t));
            ++current_id;
        }

        for (auto &thread : threads) {
            result.push_back(futures[oldest_id].get());
            thread.join();
            ++oldest_id;
        }

        return result;
    }

    virtual std::string getInnerName() { return "TeamNewThreads"; }
};

class TeamConstThreads : public TeamThreads {
public:
    TeamConstThreads(uint32_t sizeArg, bool shareResults) : TeamThreads(sizeArg,
                                                                        shareResults) {}

    virtual ContestResult runContest(ContestInput const &contestInput) {
        this->resetThreads();
        ContestResult result = this->runContestImpl(contestInput);
        assert(this->getSize() == this->getCreatedThreads());
        return result;
    }

    virtual ContestResult runContestImpl(ContestInput const &contestInput) {
        ContestResult result;
        // for name simplicity
        uint64_t THREAD_COUNT = this->getSize();
        uint64_t CONTEST_SIZE = contestInput.size();
        // each thread has its own vector of promises
        std::vector<std::promise<uint64_t>> promises[THREAD_COUNT];
        // only one, but larger, vector of futures, because a vector of vectors
        // is not necessary and it's easier to get them in order later
        std::vector<std::future<uint64_t>> futures(contestInput.size());
        // each thread has its own vector of assigned contests
        std::vector<InfInt> assigned_contests[THREAD_COUNT];

        for (uint64_t i = 0; i < CONTEST_SIZE; ++i) {
            std::promise<uint64_t> prom;
            promises[i % THREAD_COUNT].push_back(std::move(prom));
            // get the latest promise
            futures[i] = promises[i % THREAD_COUNT].back().get_future();
            // (i * THREAD_COUNT)-th thread gets i-th contest assigned
            assigned_contests[i % THREAD_COUNT].push_back(contestInput[i]);
        }

        for (uint64_t i = 0; i < THREAD_COUNT; ++i) {
            std::thread t = createThread(
                    [&, &contests = assigned_contests[i],
                            &proms = promises[i]] {
                        if (this->getSharedResults()) {
                            for (uint64_t i = 0; i < contests.size(); ++i)
                                proms[i].set_value(this->getSharedResults()
                                                           ->sharedCalcCollatz(
                                                                   contests[i]));
                        } else {
                            for (uint64_t i = 0; i < contests.size(); ++i)
                                proms[i].set_value(calcCollatz(contests[i]));
                        }
                    });
            t.detach();

        }

        for (auto &future : futures)
            result.push_back(future.get());

        return result;
    }


    virtual std::string getInnerName() { return "TeamConstThreads"; }
};

class TeamPool : public Team {
public:
    TeamPool(uint32_t sizeArg, bool shareResults) : Team(sizeArg, shareResults),
                                                    pool(sizeArg) {}


    virtual ContestResult runContest(ContestInput const &contestInput) {
        ContestResult result;

        uint64_t CONTEST_SIZE = contestInput.size();
        std::vector<std::future<uint64_t>> futures;

        auto pool_collatz =
                [this](const InfInt &contest) {
                    if (this->getSharedResults())
                        return this->getSharedResults()->sharedCalcCollatz(
                                contest);
                    // not shared
                    return calcCollatz(contest);
                };

        for (uint64_t i = 0; i < CONTEST_SIZE; ++i)
            futures.push_back(pool.push(pool_collatz, contestInput[i]));

        result = cxxpool::get(futures.begin(), futures.end());
        return result;
    }

    virtual std::string getInnerName() { return "TeamPool"; }

private:
    cxxpool::thread_pool pool;
};

class TeamNewProcesses : public Team {
public:
    TeamNewProcesses(uint32_t sizeArg, bool shareResults) : Team(sizeArg,
                                                                 shareResults) {}

    virtual ContestResult runContest(ContestInput const &contestInput) {
        ContestResult result;
        std::string input[contestInput.size()];
        std::string output[contestInput.size()];
        for (int i = 0; i < contestInput.size(); ++i) {
            input[i] = "/tmp/input" + std::to_string(i);
            output[i] = "/tmp/output" + std::to_string(i);
        }
        int desc[contestInput.size()];
        int desc_output[contestInput.size()];
        int process_count = 0;
        int finished_count = 0;
        for (int i = 0; i < contestInput.size(); ++i) {
            try {
                std::filesystem::remove(input[i]);
                std::filesystem::remove(output[i]);
            } catch (const std::filesystem::filesystem_error &e) {
                exit(-1);
            }
            const char *in = input[i].c_str();
            if (mkfifo(in, 0755) == -1)
                exit(42);
            const char *out = output[i].c_str();
            if (mkfifo(out, 0755) == -1)
                exit(42);
            if (process_count == this->getSize()) {
                desc_output[finished_count] = open(output[finished_count].c_str(), O_RDONLY);
                if (desc_output[finished_count] == -1) {
                    std::cout << "wylew descc output tutaj\n";
                    exit(-1);
                }

                uint64_t partial_result;
                if (read(desc_output[finished_count], &partial_result, sizeof(uint64_t)) < 0) {
                    std::cout << "zle wczytana dlugosc\n";
                    exit(1);
                }
                result.push_back(partial_result);
                if (close(desc_output[finished_count])) {
                    std::cout << "wylew close";
                    exit(1);
                }
                if (wait(0) == -1)
                    exit(17);


                finished_count++;
                process_count--;
            }
            process_count++;
            std::string cnt = "1";
            switch (fork()) {
                case -1:
                    exit(1);

                case 0:
                    execlp("./new_process", "./new_process",
                           input[i].c_str(), output[i].c_str(),
                           cnt.c_str(),NULL);
                    break;

                default:
                    desc[i] = open(input[i].c_str(), O_WRONLY);
                    if (desc[i] == -1) {
                        std::cout << "wylew desc tutaj";
                        exit(-1);
                    }
                    // dlugosc inputu
                    size_t len = contestInput[i].numberOfDigits();
                    if (write(desc[i], &len,
                              sizeof(size_t)) < 0)
                        exit(2);

                    // sam input
                    if (write(desc[i], contestInput[i].toString().c_str(),
                              len) < 0)
                        exit(2);

                    if (close(desc[i])) {
                        std::cout << "wylew close";
                        exit(1);
                    }

                    break;
            }
        }


        for (int i = finished_count; i < contestInput.size(); ++i) {
            desc_output[i] = open(output[i].c_str(), O_RDONLY);
            if (desc_output[i] == -1) {
                std::cout << "wylew descc output tutaj\n";
                exit(-1);
            }

            uint64_t partial_result;
            if (read(desc_output[i], &partial_result, sizeof(uint64_t)) < 0) {
                std::cout << "zle wczytana dlugosc\n";
                exit(1);
            }
            result.push_back(partial_result);
            if (close(desc_output[i])) {
                std::cout << "wylew close";
                exit(1);
            }
        }
        while (process_count--) {
            if (wait(0) == -1)
                exit(17);
        }


        for (int i = 0; i < contestInput.size(); ++i) {
            if (unlink(input[i].c_str()))
                exit(16);
            if (unlink(output[i].c_str()))
                exit(16);
        }

        return result;
    }

    virtual std::string getInnerName() { return "TeamNewProcesses"; }
};

class TeamConstProcesses : public Team {
public:
    TeamConstProcesses(uint32_t sizeArg, bool shareResults) : Team(sizeArg,
                                                                   shareResults) {}

    virtual ContestResult runContest(ContestInput const &contestInput) {
        ContestResult result;
        uint64_t PROCESS_COUNT = this->getSize();
        uint64_t CONTEST_SIZE = contestInput.size();
        // a vector for each process
        std::vector<InfInt> assigned_contests[PROCESS_COUNT];
        std::string input[PROCESS_COUNT];
        std::string output[PROCESS_COUNT];
        for (int i = 0; i < PROCESS_COUNT; ++i) {
            input[i] = "/tmp/input" + std::to_string(i);
            output[i] = "/tmp/output" + std::to_string(i);
        }
        // spread work evenly
        for (int i = 0; i < PROCESS_COUNT; ++i) {
            assigned_contests[i % PROCESS_COUNT].push_back(contestInput[i]);
        }
        int desc[PROCESS_COUNT];
        int desc_output[PROCESS_COUNT];
        // iterate only through as many processes as we are allowed to have
        for (int i = 0; i < PROCESS_COUNT; ++i) {
            try {
                std::filesystem::remove(input[i]);
                std::filesystem::remove(output[i]);
            } catch (const std::filesystem::filesystem_error &e) {
                exit(-1);
            }
            const char *in = input[i].c_str();
            if (mkfifo(in, 0755) == -1)
                exit(42);
            const char *out = output[i].c_str();
            if (mkfifo(out, 0755) == -1)
                exit(42);
            std::string cnt = std::to_string(assigned_contests[i].size());
            switch (fork()) {
                case -1:
                    exit(1);

                case 0:
                    execlp("./new_process", "./new_process",
                           input[i].c_str(), output[i].c_str(),
                           cnt.c_str(), NULL);

                    break;

                default:
                    desc[i] = open(input[i].c_str(), O_WRONLY);
                    if (desc[i] == -1) {
                        std::cout << "wylew desc tutaj";
                        exit(-1);
                    }
                    printf("wpisuje cos\n");
                    for (int j = 0; j < assigned_contests[i].size(); ++j) {
                        size_t len = contestInput[i].numberOfDigits();
                        if (write(desc[i], &len,
                                  sizeof(size_t)) < 0)
                            exit(2);

                        // sam input
                        if (write(desc[i], contestInput[i].toString().c_str(),
                                  len) < 0)
                            exit(2);

                    }
                    if (close(desc[i])) {
                        std::cout << "wylew close";
                        exit(1);
                    }
                    break;
            }

        }
        for (int i = 0; i < PROCESS_COUNT; ++i) {
            desc_output[i] = open(output[i].c_str(), O_RDONLY);
            if (desc_output[i] == -1) {
                std::cout << "wylew descc output tutaj\n";
                exit(-1);
            }

            uint64_t partial_result;
            for (int j = 0; j < assigned_contests[i].size(); ++j) {
                if (read(desc_output[i], &partial_result, sizeof(uint64_t)) < 0) {
                    std::cout << "zle wczytana dlugosc\n";
                    exit(1);
                }
                result.push_back(partial_result);
            }
            if (close(desc_output[i])) {
                std::cout << "wylew close";
                exit(1);
            }
        }
        for (int i = 0; i < PROCESS_COUNT; ++i) {
            if (wait(0) == -1)
                exit(17);
        }
        for (int i = 0; i < PROCESS_COUNT; ++i) {
            if (unlink(input[i].c_str()))
                exit(16);
            if (unlink(output[i].c_str()))
                exit(16);
        }
        for (auto a : result)
            std::cout << a << '\n';
        return result;
    }

    virtual std::string getInnerName() { return "TeamConstProcesses"; }
};

class TeamAsync : public Team {
public:
    TeamAsync(uint32_t sizeArg, bool shareResults) : Team(1,
                                                          shareResults) {} // ignore size

    virtual ContestResult runContest(ContestInput const &contestInput) {
        ContestResult result;

        std::vector<std::future<uint64_t>> futures;

        for (auto &contest : contestInput) {
            futures.push_back(std::async([&] {
                if (this->getSharedResults())
                    return this->getSharedResults()->sharedCalcCollatz(contest);
                // not shared
                return calcCollatz(contest);
            }));
        }

        for (auto &future : futures)
            result.push_back(future.get());

        return result;
    }

    virtual std::string getInnerName() { return "TeamAsync"; }
};

#endif
